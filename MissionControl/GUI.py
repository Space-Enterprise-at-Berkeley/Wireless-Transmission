import matplotlib
matplotlib.use('Qt5Agg')

from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure

import random, time, sys, os
from datetime import datetime

# Contains Thread Definitions
from GUI_threads import *
from packet import *
from Sensor_IDs import *

"""
GUI.py
Interpret and graph live telemetry during a test (waterflow, coldflow, static fire). Provides Graphic User Interface
(GUI) through which the Ground Station operator can view incoming telemetery and send commands to the flight computer

See GUI_threads for class to handle serial input/updating graphs.
See packet for class to decode from raw strings to packet objects and vice versa.
See Sensor_IDs for dicts used to associate packet IDs to their respective graphs

Classes:

    MplCanvas
    StatusGroup
    Status
    MainWindow
    Entry

Functions:

    full_file_name(base_name)

Misc variables:

    N/A
"""


sensor_name_to_text = {
        "low_pt" : "Low Pressure",
        "high_pt" : "High Pressure",
        "temp" : "Temperature"
}


'''Given a base file name BASE_NAME, will return the correct full name "BASE_NAME_YYYY-MM-DD_"'''
def full_file_name(base_name):
    return "{}_{}.csv".format(base_name,datetime.now().strftime('%Y-%m-%d__%H_%M'))

class MplCanvas(FigureCanvasQTAgg):

    def __init__(self, parent=None, width=5, height=4, dpi=100, fig=None, nrows=None, ncols=None, index=None):
        if fig:
            self.axes = fig.add_subplot(nrows,ncols,index)
        else:
            fig = Figure(figsize=(width, height), dpi=dpi)
            # nrows ncols index
            self.axes = fig.add_subplot(1,1,1)

        super(MplCanvas, self).__init__(fig)

class StatusGroup(QWidget):
    def __init__(self, name, id, valve_signals, *args, **kwargs):
        super(StatusGroup, self).__init__(*args, **kwargs)

        self.valve_signals = valve_signals
        self.name = name
        self.id = id
        layout = QGridLayout()

        self.open_btn = QPushButton("OPEN")
        self.open_btn.setFont(QFont("Helvetica Neue"))
        self.open_btn.clicked.connect(self.open_act)
        self.close_btn = QPushButton("CLOSE")
        self.close_btn.setFont(QFont("Helvetica Neue"))
        self.close_btn.clicked.connect(self.close_act)
        self.status = Status()

        layout.addWidget(self.open_btn,0,0)
        layout.addWidget(self.close_btn,1,0)
        layout.addWidget(self.status,0,1,2,1)

        self.setLayout(layout)
        self.setMaximumHeight(80)

    def open_act(self):
        if self.status.closed:
            self.status.switch()
        pack = Packet('1',id=self.id,)
        self.valve_signals[self.name] = pack.encode_data()
        print("Opening " + self.name)
        print(self.valve_signals[self.name])

    def close_act(self):
        if not self.status.closed:
            self.status.switch()
        pack = Packet('0',id=self.id,)
        self.valve_signals[self.name] = pack.encode_data()
        print("Closing " + self.name)
        print(self.valve_signals[self.name])

class Status(QWidget):
    def __init__(self, *args, **kwargs):
        super(Status, self).__init__(*args, **kwargs)
        self.setAutoFillBackground(True)

        self.closed_txt = "<font color='White'>CLOSED</font>"
        self.open_txt = "  OPEN"
        self.color = 'red'
        self.closed = True
        self.set_color(self.color)


        layout = QVBoxLayout()
        self.l = QLabel(self.closed_txt)
        labelfont = QFont("Helvetica Neue", 14, QFont.Bold)
        labelfont.setLetterSpacing(QFont.PercentageSpacing, 105)
        self.l.setFont(labelfont)

        layout.addWidget(self.l, Qt.AlignCenter)

        self.setLayout(layout)

        self.setMaximumHeight(60)
        self.setMinimumWidth(90)
        self.setMaximumWidth(90)

    def switch(self):
        if self.color == 'red':
            # Change to open (green)
            self.color = 'green'
            self.l.setText(self.open_txt)
            self.set_color("#60d936") # Light Green
            self.closed = False
            # TODO: VALVE OPENING ACTION
        elif self.color == 'green':
            # Change to closed (red)
            self.color = 'red'
            self.l.setText(self.closed_txt)
            self.set_color("#ee230c") # Bright Red
            self.closed = True
            # TODO: VALVE CLOSING ACTION

    def set_color(self, color):
        palette = self.palette()
        palette.setColor(QPalette.Window, QColor(color))
        self.setPalette(palette)


class MainWindow(QMainWindow):
    '''
    Main GUI Window

    file_path - path that includes directory & autogenerated filename

    sensor_types - a list of the types of sensors that have at least one sensor connected

    sensor_nums - a dictionary of sensor nums, for all sensor types that have at least
    one sensor connected

    '''


    def __init__(self, file_path, sensor_types, sensor_nums, *args, **kwargs):
        super(MainWindow, self).__init__(*args, **kwargs)

        # Dictionary of maximum sensor nums, based of sensor type ID
        self.sensor_max_nums = {'low_pt':4,'high_pt':1,'temp':6,'load':2}

        self.sensor_types = sensor_types.copy()
        self.sensor_nums = sensor_nums.copy()
        self.all_sensors = {}
        # Defining the order of graphs for each type of data
        self.all_sensors['low_pt'] = ["lox_injector", "prop_injector", "lox_tank", "prop_tank"]
        self.all_sensors['high_pt'] = ["pressurant"]
        self.all_sensors['temp'] = ["temp1","temp2","temp3","temp4","temp5","temp6"]
        self.all_sensors['load_cell'] = ["load_cell_1","load_cell_1"]
        # self.all_sensor = ['pressure', 'temperature', 'battery']
        self.all_sensors["low_pt"] = "pressure"
        self.all_sensors["high_pt"] = "pressure"
        self.all_sensors["temp"] = "temperature"

        mainlayout = QGridLayout()

        # row 0

        title = QLabel("Ground Dashboard")
        title.setFont(QFont("Lucida Grande",20, QFont.Bold))

        self.recording_display = QLabel("Recording")
        self.recording_display.setFont(QFont("Lucida Grande",14))

        mainlayout.addWidget(title,0,0,1,2)
        mainlayout.addWidget(self.recording_display,0,0,Qt.AlignCenter)

        # ---------- Valves -----------------------------------------

        self.valve_signals = {}

        # Dynamically create StatusGroup objects and formatted labels for all valves

        valves = ["Pressurant", "LOX GEMS", "Propane GEMS", "LOX 2-WAY",
        "Propane 2-WAY", "LOX 5-WAY", "Propane 5-WAY", "Both 5-WAY"]
        valve_ids = [26, 22, 25, 20, 23, 21, 24, 28]
        self.StatusGroups = {}
        for i in range(len(valves)):
            self.StatusGroups[valves[i]] = StatusGroup(valves[i],valve_ids[i],self.valve_signals)
            self.valve_signals[valves[i]] = 0

        label_names = ['Pressurant', 'LOX', 'Propane', 'GEMS', '2-WAY', '5-WAY', 'BOTH 5-WAY']
        valve_labels = {}
        for i,name in enumerate(label_names):
            label = QLabel(name)
            font = QFont("Lucida Grande",14, QFont.Bold)
            label.setFont(font)
            valve_labels[name] = label

        # Buttons for opening Both 5-Ways

        open_5ways_btn = QPushButton("OPEN")
        open_5ways_btn.setFont(QFont("Helvetica Neue"))
        open_5ways_btn.clicked.connect(self.toggle_5ways)
        open_5ways_btn.setMaximumWidth(100)
        close_5ways_btn = QPushButton("CLOSE")
        close_5ways_btn.setFont(QFont("Helvetica Neue"))
        close_5ways_btn.clicked.connect(self.toggle_5ways)
        close_5ways_btn.setMaximumWidth(100)
        self._5ways_open = False
        _5way_btn_container = QWidget()
        _5way_btn_layout = QVBoxLayout()
        _5way_btn_layout.addWidget(open_5ways_btn)
        _5way_btn_layout.addWidget(close_5ways_btn)
        _5way_btn_container.setLayout(_5way_btn_layout)
        _5way_btn_container.setMaximumWidth(90)
        pressure_gems_btn = QPushButton("PRESSURE+GEMS")
        pressure_gems_btn.setFont(QFont("Helvetica Neue"))
        pressure_gems_btn.clicked.connect(self.pressure_gems)


        # Button & Text Fields to control Saving of Data
        self.recording = False
        self.save_data_btn = QPushButton("Start Recording")
        self.save_data_btn.clicked.connect(self.record_data)
        self.recording_timer = QTimer()
        self.recording_timer.timeout.connect(self.showTime)
        self.recording_display_showing = False
        self.recording_timer.start(1000)

        self.recording_text = ["LOX Dome:", "Propane Dome:", "File Name:"]
        recording_containers = []
        self.recording_labels = []
        self.recording_line_edits = []
        for i in range(len(self.recording_text)):
            container = QWidget()
            box_layout = QHBoxLayout()
            label = QLabel(self.recording_text[i])
            label.setFont(QFont("Lucida Grande",14, QFont.Bold))
            box_layout.addWidget(label)
            line_edit = QLineEdit()
            if self.recording_text[i] == "File Name:":
                line_edit.setText("waterflow")
            box_layout.addWidget(line_edit)
            container.setLayout(box_layout)
            self.recording_line_edits.append(line_edit)
            self.recording_labels.append(label)
            recording_containers.append(container)
        # Connect file name line edit to label
        self.recording_line_edits[2].textChanged.connect(self.update_file_name)
        self.file_name_label = QLabel(full_file_name("waterflow"))

        # Put StatusGroup objects and labels in valve GridLayout, as outlined in rough draft diagram

        valve_container = QWidget()
        valve_layout = QGridLayout()
        # row 0 & 1
        valve_layout.addWidget(recording_containers[0],0,1)
        valve_layout.addWidget(recording_containers[1],0,2)
        valve_layout.addWidget(recording_containers[2],1,1)
        valve_layout.addWidget(self.file_name_label,1,2)
        valve_layout.addWidget(self.save_data_btn,1,0)

        valves_start_row = 2
        # row 2 & 3
        valve_layout.addWidget(valve_labels["Pressurant"],valves_start_row+0,1,1,2,Qt.AlignCenter)
        valve_layout.addWidget(self.StatusGroups['Pressurant'],valves_start_row+1,1,1,2,Qt.AlignCenter)
        # row 4
        valve_layout.addWidget(valve_labels["LOX"],valves_start_row+2,1,Qt.AlignCenter)
        valve_layout.addWidget(valve_labels["Propane"],valves_start_row+2,2,Qt.AlignCenter)
        # row 5
        valve_layout.addWidget(valve_labels["GEMS"],valves_start_row+3,0)
        valve_layout.addWidget(self.StatusGroups['LOX GEMS'],valves_start_row+3,1)
        valve_layout.addWidget(self.StatusGroups['Propane GEMS'],valves_start_row+3,2)
        # row 6
        valve_layout.addWidget(valve_labels["2-WAY"],valves_start_row+4,0)
        valve_layout.addWidget(self.StatusGroups['LOX 2-WAY'],valves_start_row+4,1)
        valve_layout.addWidget(self.StatusGroups['Propane 2-WAY'],valves_start_row+4,2)
        # row 7
        valve_layout.addWidget(valve_labels["5-WAY"],valves_start_row+5,0)
        valve_layout.addWidget(self.StatusGroups['LOX 5-WAY'],valves_start_row+5,1)
        valve_layout.addWidget(self.StatusGroups['Propane 5-WAY'],valves_start_row+5,2)
        # row 8
        valve_layout.addWidget(valve_labels['BOTH 5-WAY'],valves_start_row+6,0)
        valve_layout.addWidget(_5way_btn_container,valves_start_row+6,1,Qt.AlignCenter)
        valve_layout.addWidget(pressure_gems_btn,valves_start_row+6,2,Qt.AlignCenter)



        valve_container.setLayout(valve_layout)
        mainlayout.addWidget(valve_container,1,0)

        # ---------- Graphs -----------------------------------------

        # Dynamically create the correct number of graphs based off input numbers
        graphWidget = QTabWidget()
        self.graphs = []
        self.figures = {}
        self.graph_nums = [4,1,6,4]
        self.tab_titles = ["Low Pressure", "High Pressure", "Misc.","Temp"]
        for i in range(4): #self.sensor_types:
            # TODO: make graph allocation more generalized,
            # since we may have more than 6 of a given type of sensor (temp?)
            # self.graphs[sensor_type] = []
            # num = self.sensor_max_nums[sensor_type]
            num = self.graph_nums[i]
            tabWidget = QWidget()
            tabGrid = QGridLayout()
            if num == 1:
                grid_pos = self.generate_pos(1,1)
            elif num == 2:
                grid_pos = self.generate_pos(1,2)
            elif num <= 4:
                grid_pos = self.generate_pos(2,2)
            else:
                grid_pos = self.generate_pos(2,3)

            # fig = Figure(figsize=(5, 4), dpi=100)
            # self.figures[sensor] = fig
            self.graphs.append([])
            for sensor in range(num):
                canvas = MplCanvas(self,width=5, height=4, dpi=100)
                # Add canvas to a dictionary where key is the unique ID
                self.graphs[i].append(canvas)
                row,col = next(grid_pos)
                tabGrid.addWidget(canvas,row,col)
            tabWidget.setLayout(tabGrid)
            graphWidget.addTab(tabWidget, self.tab_titles[i])
        mainlayout.addWidget(graphWidget,1,1,2,1)


        # Creates a threadpool to handle scheduled threads
        self.threadpool = QThreadPool()

        # Create Main Data Gathering Thread
        self.serialThread = SerialThread(self.graphs, self.sensor_nums, self.valve_signals, file_path)
        self.serialThread.signals.data.connect(self.beans)
        self.threadpool.start(self.serialThread)




        # ---------- Display ----------------------------------------

        # Add layout to a dummy QWidget, and set it as the Central Widget
        widget = QWidget()
        widget.setLayout(mainlayout)

        self.setCentralWidget(widget)



    def toggle_5ways(self):
        if self._5ways_open:
            self.StatusGroups["LOX 5-WAY"].status.switch()
            self.StatusGroups["Propane 5-WAY"].status.switch()
            self.StatusGroups["Both 5-WAY"].close_act()
            # print("Closing 5-Way Solenoids")
            self._5ways_open = False
        else:
            self.StatusGroups["LOX 5-WAY"].status.switch()
            self.StatusGroups["Propane 5-WAY"].status.switch()
            self.StatusGroups["Both 5-WAY"].open_act()
            # print("Opening 5-Way Solenoids")
            self._5ways_open = True

    def pressure_gems(self):

        # self.StatusGroups["Pressurant"].status.switch()
        self.StatusGroups["Pressurant"].open_act()
        time.sleep(0.5)
        # self.StatusGroups["Propane GEMS"].status.switch()
        # self.StatusGroups["LOX GEMS"].status.switch()
        self.StatusGroups["LOX GEMS"].close_act()
        time.sleep(0.075)
        self.StatusGroups["Propane GEMS"].close_act()


    def showTime(self):
        if self.recording:
            if self.recording_display_showing:
                self.recording_display.setHidden(True)
            else:
                self.recording_display.setHidden(False)
            self.recording_display_showing = not self.recording_display_showing

    def record_data(self):
        if not self.recording:
            file_name = full_file_name(self.recording_line_edits[2].text())
            # Add metadata to top of file. For now, only the dome pressures being used.
            metadata = ''
            for i in range(2):
                metadata += "{} {} ".format(self.recording_labels[i].text(),self.recording_line_edits[i].text())
            self.serialThread.start_saving_test(file_name, metadata)
            self.save_data_btn.setText("Stop Recording")
        else:
            self.serialThread.stop_saving_test()
            self.save_data_btn.setText("Start Recording")
            self.recording_display.setHidden(True)

        self.recording = not self.recording

    def update_file_name(self):
        file_name = full_file_name(self.recording_line_edits[2].text())
        self.file_name_label.setText(file_name)


    def beans(self, num):
        print("{} beans".format(num))

    def generate_pos(self,nrows,ncols):
        rows = 0
        cols = 0
        while rows < nrows:
            while cols < ncols:
                yield (rows,cols)
                cols += 1
            cols = 0
            rows += 1

    # Override close event to stop threads
    def closeEvent(self, event):
        print("Shutting down threads")
        self.serialThread.stop_thread()
        time.sleep(0.2)
        event.accept()


class Entry(QMainWindow):
    def __init__(self, parent=None):
        super(Entry, self).__init__(parent)

        self.sensors = ["low_pt", "high_pt", "temp"]
        self.sensor_nums = {}

        mainlayout = QGridLayout()

        # row 0

        title = QLabel("Dashboard Settings")
        title.setFont(QFont("Lucida Grande",20, QFont.Bold))

        mainlayout.addWidget(title,0,0,1,2)

        self.storage_path = 'data'

        label_names = ['Base Filename:', 'Folder:', 'File Path:','# Low PTs:', '# High PTs:', '# Temp Sensors:']
        label_ids = ['base_file', 'folder', 'file_path', 'low_pt', 'high_pt', 'temp']
        self.labels = {}
        line_edit_defaults = ['waterflow', self.storage_path, '', '4', '1','6']
        self.line_edits = {}
        label_font = QFont("Lucida Grande",14, QFont.Bold)
        for i,name in enumerate(label_names):
            label = QLabel(name)
            label.setFont(label_font)
            self.labels[label_ids[i]] = label
            mainlayout.addWidget(label,i+1,0)
            # create a QLineEdit for all rows except 'File Path'
            if name =='File Path:':
                line_edit = QLabel('')
                self.labels['file_path_text'] = line_edit
            else:
                line_edit = QLineEdit()
                line_edit.setText(line_edit_defaults[i])
                self.line_edits[label_ids[i]] = line_edit
            mainlayout.addWidget(line_edit,i+1,1)

        # Set various object settings
        # Use a validator to restrict possible values for text fields
        self.line_edits['low_pt'].setValidator(QIntValidator(0,5))
        self.line_edits['high_pt'].setValidator(QIntValidator(0,2))
        self.line_edits['temp'].setValidator(QIntValidator(0,7))
        self.line_edits['base_file'].textChanged.connect(self.update_full_file_path)
        self.line_edits['folder'].textChanged.connect(self.update_full_file_path)
        self.update_full_file_path()


        self.launchButton = QPushButton("Launch Dashboard")
        mainlayout.addWidget(self.launchButton,len(label_names) + 1,0,1,2,Qt.AlignCenter)
        self.launchButton.clicked.connect(self.on_launchButton_clicked)

        # Dummy container widget
        widget = QWidget()
        widget.setLayout(mainlayout)
        self.setCentralWidget(widget)


    def update_full_file_path(self):
        self.file_name = full_file_name(self.line_edits['base_file'].text())
        self.folder_name = self.line_edits['folder'].text()
        self.labels['file_path_text'].setText(os.path.join(self.folder_name,"raw_"+self.file_name))


    def update_sensor_vals(self):
        for sensor_type in self.sensors:
            val = int(self.line_edits[sensor_type].text())
            self.sensor_nums[sensor_type] = val


    def on_launchButton_clicked(self):
        if not os.path.isdir(self.folder_name):
            message = '''<p>The given folder to save data in does not exist:</p>    {}
                    <p>Would you like to create the a new folder with the given name?</p>'''.format(folder_name)
            msgBox = QMessageBox(QMessageBox.Warning,
                    "QMessageBox.warning()", message,
                    QMessageBox.NoButton, self)
            msgBox.addButton("Create", QMessageBox.AcceptRole)
            msgBox.addButton("Cancel", QMessageBox.RejectRole)
            if msgBox.exec_() == QMessageBox.AcceptRole:
                os.mkdir(self.folder_name)
            else:
                return

        self.update_sensor_vals()
        self.mainWindow = MainWindow(self.labels['file_path_text'].text(), list(self.sensor_nums.keys()), self.sensor_nums)
        self.mainWindow.show()
        self.hide()


def main():
    app = QApplication(sys.argv)
    w = Entry()
    w.show()
    app.exec_()

if __name__ == '__main__':
    main()
